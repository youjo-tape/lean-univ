import kassel.enhanced_R_matrix
import tactic.field_simp
import kassel.kronecker_appendix

namespace kassel
namespace jones

variables {K: Type*} [field K]

lemma pow_mul_single (a: K) (n: ‚Ñï): a ^ n * a = a ^ (n + 1) := by nth_rewrite 1 ‚Üêpow_one a; rw pow_add
lemma single_mul_pow (a: K) (n: ‚Ñï): a * a ^ n = a ^ (1 + n) := by nth_rewrite 0 ‚Üêpow_one a; rw pow_add

@[simp] def V‚ÇÇ: FinVect K := ‚ü®‚ü®bool ‚Üí K‚ü©, begin
  change finite_dimensional K (bool ‚Üí K),
  exact finite_dimensional.finite_dimensional_pi K,
end‚ü©

section

variables (q: KÀ£)

@[simp] def R_matrix: matrix (bool √ó bool) (bool √ó bool) K 
  | (ff, ff) (ff, ff) := q‚Åª¬π
  | (ff, tt) (tt, ff) := (q‚Åª¬π)^2
  | (tt, ff) (ff, tt) := (q‚Åª¬π)^2
  | (tt, ff) (tt, ff) := q‚Åª¬π + -(q‚Åª¬π)^3
  | (tt, tt) (tt, tt) := q‚Åª¬π
  | _ _ := 0

@[simp] def R_matrix_inv: matrix (bool √ó bool) (bool √ó bool) K
  | (ff, ff) (ff, ff) := q
  | (ff, tt) (ff, tt) := q + -q^3
  | (ff, tt) (tt, ff) := q^2
  | (tt, ff) (ff, tt) := q^2
  | (tt, tt) (tt, tt) := q
  | _ _ := 0

noncomputable def R_hom :=
  matrix.to_lin
    ((pi.basis_fun K bool).tensor_product (pi.basis_fun K bool))
    ((pi.basis_fun K bool).tensor_product (pi.basis_fun K bool))
    (R_matrix q)

noncomputable def R_inv :=
  matrix.to_lin
    ((pi.basis_fun K bool).tensor_product (pi.basis_fun K bool))
    ((pi.basis_fun K bool).tensor_product (pi.basis_fun K bool))
    (R_matrix_inv q)

def Œº_hom: (bool ‚Üí K) ‚Üí‚Çó[K] (bool ‚Üí K) := ((q‚Åª¬π)^2: K) ‚Ä¢ linear_map.id
def Œº_inv: (bool ‚Üí K) ‚Üí‚Çó[K] (bool ‚Üí K) := (q^2: K) ‚Ä¢ linear_map.id

end

variables {q: KÀ£}

lemma matrix_to_Œº_hom:
  matrix.to_lin (pi.basis_fun K bool) (pi.basis_fun K bool) (((q‚Åª¬π)^2: K) ‚Ä¢ 1) = Œº_hom q
:=
  by rw [Œº_hom, linear_equiv.map_smul, matrix.to_lin_one]

lemma matrix_to_Œº_inv:
  matrix.to_lin (pi.basis_fun K bool) (pi.basis_fun K bool) ((q^2: K) ‚Ä¢ 1) = Œº_inv q
:=
  by rw [Œº_inv, linear_equiv.map_smul, matrix.to_lin_one]

lemma R_hom_inv_id: R_inv q ‚àò‚Çó R_hom q = linear_map.id := begin
  rw [R_hom, R_inv, ‚Üêmatrix.to_lin_mul],
  rw ‚Üêmatrix.to_lin_one ((pi.basis_fun K bool).tensor_product (pi.basis_fun K bool)),
  congr,
  ext ‚ü®i‚ÇÅ, i‚ÇÇ‚ü© ‚ü®k‚ÇÅ, k‚ÇÇ‚ü©,
  simp_rw matrix.mul_apply,
  dsimp,
  simp_rw [‚Üêfinset.univ_product_univ, finset.sum_product, fintype.sum_bool],
  cases i‚ÇÅ; cases i‚ÇÇ; cases k‚ÇÅ; cases k‚ÇÇ; simp,
  field_simp,
  simp [left_distrib, right_distrib, ‚Üêpow_add, neg_mul, pow_mul_single, single_mul_pow],
  have: 5 + 0 = 5 := rfl, rw this,
  have: 7 + 0 = 7 := rfl, rw this,
  rw ‚Üêadd_assoc, rw add_assoc ((q: K)^7) _ _,
  simp,
end

lemma R_inv_hom_id: R_hom q ‚àò‚Çó R_inv q = linear_map.id := begin
  rw [R_hom, R_inv, ‚Üêmatrix.to_lin_mul],
  rw ‚Üêmatrix.to_lin_one ((pi.basis_fun K bool).tensor_product (pi.basis_fun K bool)),
  congr,
  ext ‚ü®i‚ÇÅ, i‚ÇÇ‚ü© ‚ü®k‚ÇÅ, k‚ÇÇ‚ü©,
  simp_rw matrix.mul_apply,
  dsimp,
  simp_rw [‚Üêfinset.univ_product_univ, finset.sum_product, fintype.sum_bool],
  cases i‚ÇÅ; cases i‚ÇÇ; cases k‚ÇÅ; cases k‚ÇÇ; simp,
  field_simp,
  simp [right_distrib, ‚Üêpow_add, neg_mul, pow_mul_single, single_mul_pow],
  have: 5 + 0 = 5 := rfl, rw this,
  have: 7 + 0 = 7 := rfl, rw this,
  rw ‚Üêadd_assoc, rw add_assoc ((q: K)^7) _ _,
  simp,
end

lemma Œº_hom_inv_id: Œº_inv q ‚àò‚Çó Œº_hom q = linear_map.id :=
  by simp [Œº_hom, Œº_inv, linear_map.smul_comp, linear_map.comp_smul]

lemma Œº_inv_hom_id: Œº_hom q ‚àò‚Çó Œº_inv q = linear_map.id :=
  by simp [Œº_hom, Œº_inv, linear_map.smul_comp, linear_map.comp_smul]

/-noncomputable def assoc_to_mat {m n p}
  [fintype m] [fintype n] [fintype p]
  [decidable_eq ((m √ó n) √ó p)] :=
  
  linear_map.to_matrix
    (((pi.basis_fun K m).tensor_product (pi.basis_fun K n)).tensor_product (pi.basis_fun K p))
    ((pi.basis_fun K m).tensor_product ((pi.basis_fun K n).tensor_product (pi.basis_fun K p)))
    -- (tensor_product.assoc K (m ‚Üí K) (n ‚Üí K) (p ‚Üí K)).to_linear_map
-/
-- #check assoc_to_mat (tensor_product.assoc _ _ _ _).to_linear_map

lemma R_relation_1:
  (tensor_product.assoc K _ _ _).symm.to_linear_map
  ‚àò‚Çó ((R_hom q).ltensor _)
  ‚àò‚Çó (tensor_product.assoc K _ _ _).to_linear_map
  ‚àò‚Çó ((R_hom q).rtensor _)
  ‚àò‚Çó (tensor_product.assoc K _ _ _).symm.to_linear_map
  ‚àò‚Çó ((R_hom q).ltensor _)
= 
  ((R_hom q).rtensor _)
  ‚àò‚Çó (tensor_product.assoc K _ _ _).symm.to_linear_map
  ‚àò‚Çó ((R_hom q).ltensor _)
  ‚àò‚Çó (tensor_product.assoc K _ _ _).to_linear_map
  ‚àò‚Çó ((R_hom q).rtensor _)
  ‚àò‚Çó (tensor_product.assoc K _ _ _).symm.to_linear_map
:= begin
  ext,
  sorry,
end

open_locale kronecker matrix

#check
  (R_matrix q ‚äó‚Çñ (1: matrix bool bool K))
#check
  ((1: matrix bool bool K) ‚äó‚Çñ R_matrix q)

#check matrix.reindex
  (equiv.prod_assoc bool bool bool)
  (equiv.prod_assoc bool bool bool)
  ((R_matrix q) ‚äó‚Çñ (1 : matrix bool bool K))

#check finset.sum_product

lemma my_assoc_reindex (A: matrix ((bool √ó bool) √ó bool) ((bool √ó bool) √ó bool) K):
  matrix.reindex
    (equiv.prod_assoc bool bool bool)
    (equiv.prod_assoc bool bool bool)
    A
  = my_assoc_matrix K ‚¨ù A ‚¨ù my_assoc_matrix_inv K :=
begin
  ext ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© ‚ü®j‚ÇÅ, j‚ÇÇ, j‚ÇÉ‚ü©,
  simp_rw matrix.mul_apply,
  dsimp,
  simp_rw [‚Üêfinset.univ_product_univ],
  simp_rw [finset.sum_product],
  simp_rw [fintype.sum_bool],
  cases j‚ÇÅ; cases j‚ÇÇ; cases j‚ÇÉ,
  {
    cases i‚ÇÅ; cases i‚ÇÇ; cases i‚ÇÉ; simp [my_assoc_matrix, my_assoc_matrix_inv],
  },
  {
    cases i‚ÇÅ; cases i‚ÇÇ; cases i‚ÇÉ; simp [my_assoc_matrix, my_assoc_matrix_inv],
  },
  {
    cases i‚ÇÅ; cases i‚ÇÇ; cases i‚ÇÉ; simp [my_assoc_matrix, my_assoc_matrix_inv],
  },
  {
    cases i‚ÇÅ; cases i‚ÇÇ; cases i‚ÇÉ; simp [my_assoc_matrix, my_assoc_matrix_inv],
  },
  {
    cases i‚ÇÅ; cases i‚ÇÇ; cases i‚ÇÉ; simp [my_assoc_matrix, my_assoc_matrix_inv],
  },
  {
    cases i‚ÇÅ; cases i‚ÇÇ; cases i‚ÇÉ; simp [my_assoc_matrix, my_assoc_matrix_inv],
  },
  {
    cases i‚ÇÅ; cases i‚ÇÇ; cases i‚ÇÉ; simp [my_assoc_matrix, my_assoc_matrix_inv],
  },
  {
    cases i‚ÇÅ; cases i‚ÇÇ; cases i‚ÇÉ; simp [my_assoc_matrix, my_assoc_matrix_inv],
  },

end


lemma jones_R_relation_1':
  ((1: matrix bool bool K) ‚äó‚Çñ R_matrix q)
  ‚¨ù (matrix.reindex
  (equiv.prod_assoc bool bool bool)
  (equiv.prod_assoc bool bool bool)
  ((R_matrix q) ‚äó‚Çñ (1 : matrix bool bool K)))
  ‚¨ù ((1: matrix bool bool K) ‚äó‚Çñ R_matrix q)
= 
  (matrix.reindex
  (equiv.prod_assoc bool bool bool)
  (equiv.prod_assoc bool bool bool)
  ((R_matrix q) ‚äó‚Çñ (1 : matrix bool bool K)))
  ‚¨ù ((1: matrix bool bool K) ‚äó‚Çñ R_matrix q)
  ‚¨ù (matrix.reindex
  (equiv.prod_assoc bool bool bool)
  (equiv.prod_assoc bool bool bool)
  ((R_matrix q) ‚äó‚Çñ (1 : matrix bool bool K))) :=
begin
  ext ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© ‚ü®j‚ÇÅ, j‚ÇÇ, j‚ÇÉ‚ü©,
  simp_rw matrix.mul_apply,
  dsimp,
  simp_rw [‚Üêfinset.univ_product_univ],
  simp_rw [finset.sum_product],
  simp_rw [fintype.sum_bool],

  simp only [matrix.one_apply_eq, mul_one, one_mul, matrix.one_apply_ne, ne.def, not_false_iff, mul_zero, zero_mul,
    add_zero, zero_add, R_matrix],
  cases j‚ÇÉ;
  simp only [matrix.one_apply_eq, mul_one, one_mul, matrix.one_apply_ne, ne.def, not_false_iff, mul_zero, zero_mul,
    add_zero, zero_add, R_matrix];
  cases i‚ÇÅ;
  simp only [matrix.one_apply_eq, mul_one, one_mul, matrix.one_apply_ne, ne.def, not_false_iff, mul_zero, zero_mul,
    add_zero, zero_add, R_matrix];
  cases j‚ÇÅ;
  simp only [matrix.one_apply_eq, mul_one, one_mul, matrix.one_apply_ne, ne.def, not_false_iff, mul_zero, zero_mul,
    add_zero, zero_add, R_matrix];
  cases i‚ÇÇ;
  simp only [matrix.one_apply_eq, mul_one, one_mul, matrix.one_apply_ne, ne.def, not_false_iff, mul_zero, zero_mul,
    add_zero, zero_add, R_matrix];
  cases i‚ÇÉ;
  simp only [matrix.one_apply_eq, mul_one, one_mul, matrix.one_apply_ne, ne.def, not_false_iff, mul_zero, zero_mul,
    add_zero, zero_add, R_matrix];
  cases j‚ÇÇ;
  simp only [matrix.one_apply_eq, mul_one, one_mul, matrix.one_apply_ne, ne.def, not_false_iff, mul_zero, zero_mul,
    add_zero, zero_add, R_matrix];
  ring,
end


lemma R_relation_2:
  tensor_product.map (Œº_hom q) (Œº_hom q) ‚àò‚Çó R_hom q
  = R_hom q ‚àò‚Çó tensor_product.map (Œº_hom q) (Œº_hom q)
:= begin
  sorry,
end

lemma R_relaton_3_1:

:= begin
  sorry,
end

-- trace_2 (c.hom ‚â´ (ùüô V ‚äó Œº.hom)) = ùüô V

-- coevaluation „ÅÆË®àÁÆó„ÅØ„Åß„Åç„ÇãÔºü

noncomputable def enhanced_R_matrix:
  @enhanced_R_matrix (FinVect K) _ _ _ _ _ V‚ÇÇ
:= {
  c := {
    hom := R_hom q,
    inv := R_inv q,
    hom_inv_id' := R_hom_inv_id,
    inv_hom_id' := R_inv_hom_id
  },
  Œº := {
    hom := Œº_hom q,
    inv := Œº_inv q,
    hom_inv_id' := Œº_hom_inv_id,
    inv_hom_id' := Œº_inv_hom_id
  },
  relation_1 := by apply R_relation_1,
  relation_2 := by apply R_relation_2,
  relation_3_1 := sorry,
  relation_3_2 := sorry,
  relation_4_1 := sorry,
  relation_4_2 := sorry
}

end jones
end kassel
